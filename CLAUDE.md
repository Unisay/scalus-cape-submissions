# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This repository contains UPLC-CAPE benchmark submissions implemented using Scalus, a Scala-to-Plutus compiler. The project compiles Scala code to UPLC (Untyped Plutus Core) for Cardano blockchain execution.

**Key Technologies:**
- Scalus 0.12.0 - Scala-to-Plutus compiler
- Scala 3.3.6
- sbt 1.10.1
- Plutus Core 1.1.0 target

## Development Environment

Use Nix flakes for reproducible environment:

```bash
# With direnv
direnv allow

# Or manually
nix develop
```

**Custom commands available in nix shell:**
- `build-scalus` - Compiles all Scalus scenario submissions to UPLC

## Building

**Compile Scala sources:**
```bash
sbt compile
```

**Generate UPLC programs:**
```bash
# Compile all submissions
build-scalus

# Or individually with full package path
sbt "runMain fibonacci_naive_recursion.compileFibonacciNaiveRecursion"
sbt "runMain fibonacci.compileFibonacci"
sbt "runMain factorial_naive_recursion.compileFactorialNaiveRecursion"
sbt "runMain factorial.compileFactorial"
```

**Important:** Main classes require the full package path (e.g., `fibonacci_naive_recursion.compileFibonacciNaiveRecursion`, not just `compileFibonacciNaiveRecursion`).

## Architecture

### Directory Organization

**Pattern:** `src/<scenario_name>/`

Each scenario directory contains:
- `<ScenarioName>.scala` - Source code implementation
- `<scenario>.uplc` - Compiled UPLC program (generated)
- `README.md` - Implementation description (optional)

Each scenario implementation:
1. Has a package matching the scenario name (e.g., `package fibonacci_naive_recursion`)
2. Contains an `@Compile` annotated object with the core logic
3. Defines a `@main` function to compile and write UPLC output to the same directory
4. Generates a parameterized lambda function (not pre-applied)

**Example structure:**
```scala
package fibonacci_naive_recursion

@Compile
object FibonacciNaiveRecursion:
    def fibonacci(n: BigInt): BigInt = ...

@main def compileFibonacciNaiveRecursion(): Unit =
    val program = compile(FibonacciNaiveRecursion.fibonacci)
    val term = program.toUplc()
    // Write to src/fibonacci_naive_recursion/fibonacci.uplc
```

### Current Scenarios

All scenarios are located in `src/`:

**Fibonacci:**
- `fibonacci/` - Optimized implementation using manual UPLC construction with fixed-point combinator
- `fibonacci_prepacked/` - Pre-packed ByteString lookup table (O(1) constant-time)
- `fibonacci_naive_recursion/` - Naive recursive implementation (exponential time)

**Factorial:**
- `factorial/` - Optimized factorial implementation
- `factorial_naive_recursion/` - Naive recursive factorial implementation

### UPLC Compilation Process

1. Scala code annotated with `@Compile` is processed by the Scalus compiler plugin
2. Scalus transforms Scala AST to Plutus IR
3. Output is rendered as UPLC text and written to the same `src/<scenario_name>/` directory
4. The compilation happens at Scala compile-time, producing a standalone UPLC program

**Key insight:** Functions are compiled as parameterized lambda functions that accept inputs (e.g., `\n -> ...`), not pre-applied with specific values. This allows the UPLC-CAPE benchmark framework to measure performance across different input values.

## Code Patterns

### Scenario Types

**Naive Implementations:**
- Match mathematical definitions directly
- No optimizations
- Example: Naive recursive fibonacci (exponential time)

**Optimized Implementations:**
- Performance-focused implementations
- May use tail recursion, iterative approaches, or manual UPLC construction
- Example: Iterative fibonacci with tail recursion (linear time)

### Adding New Scenarios

1. Create directory: `src/<scenario_name>/`
2. Create source file: `src/<scenario_name>/<ScenarioName>.scala`
3. Add `@Compile` annotation to the object containing the logic
4. Create a `@main` function to compile and write UPLC to `src/<scenario_name>/<scenario>.uplc`
5. Update `build-scalus` command in `flake.nix` to include new main class
6. Optionally add `README.md` describing the implementation

## UPLC-CAPE Submission Format

Each scenario directory in `src/` contains:
- `<ScenarioName>.scala` - Source code implementation
- `<scenario>.uplc` - The compiled UPLC program (parameterized lambda function)
- `README.md` - Implementation description (optional)

**Note:** Configuration and metadata files (config.json, metadata.json, metrics.json) are generated by the UPLC-CAPE benchmark framework and should not be committed to the repository.
